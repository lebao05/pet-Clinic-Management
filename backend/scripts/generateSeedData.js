#!/usr/bin/env node
/**
 * generateSeedData.js
 *
 * Generates SQL seed statements according to the user's specification.
 * By default this script performs a dry-run and writes `backend/scripts/seed.sql`.
 * Pass `--apply` to execute generated SQL against the database (USE WITH CAUTION).
 *
 * Usage:
 *   node generateSeedData.js           # writes seed.sql (dry-run)
 *   node generateSeedData.js --apply   # execute against DB (requires .env configured)
 */

const fs = require('fs');
const path = require('path');
const os = require('os');

// Config: target sizes (matching your spec)
const CONFIG = {
  branchCount: 10,
  membershipCount: 3,
  usersCount: 20000,
  petsCount: 30000,
  employeesCount: 500,
  servicesCount: 80,
  productsCount: 8000,
  inventoryCount: 70000,
  vaccinesCount: 120,
  vaccinePackagesCount: 30,
  vaccinationSubscriptionsCount: 10000,
  appointmentsCount: 70000,
  invoicesCount: 70000,
  ratingsCount: 40000,
};

// Ratios chosen per your request (50k service invoices / 20k purchase)
const RATIOS = {
  // Appointment status adjusted so Completed appointments = 50k
  appointments: {
    completedPct: 50000 / CONFIG.appointmentsCount, // 0.714285...
    bookedPct: (1 - 50000 / CONFIG.appointmentsCount) * (5 / 6), // keep Booked:Cancelled ~= 5:1
    cancelledPct: (1 - 50000 / CONFIG.appointmentsCount) * (1 / 6),
  },
  // Within completed, EXAM vs VACCINE
  completedType: { examPct: 0.6, vaccinePct: 0.4 },
};

// Output file
const OUT_SQL = path.join(__dirname, 'seed.sql');

function randInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function escape(s) {
  if (s === null || s === undefined) return 'NULL';
  return "'" + String(s).replace(/'/g, "''") + "'";
}

function writeLine(fd, line) {
  fs.writeSync(fd, line + os.EOL);
}

function emailFor(i) {
  return `user${i}@example.com`;
}

function phoneFor(i) {
  return `09${String(10000000 + i).slice(-8)}`;
}

async function generate() {
  console.log('Generating seed SQL to', OUT_SQL);
  const fd = fs.openSync(OUT_SQL, 'w');

  // Header
  writeLine(fd, '-- Seed SQL generated by generateSeedData.js');
  writeLine(fd, '-- Run in a safe/test environment first.');
  writeLine(fd, 'SET NOCOUNT ON;');
  writeLine(fd, 'GO');

  // 1) Membership (3 fixed rows)
  writeLine(fd, '\n-- Memberships');
  const memberships = [
    { RankID: 1, RankName: 'Cơ bản', DiscountPercent: 0, MinSpendPerYear: 0, KeepSpendPerYear: 0 },
    { RankID: 2, RankName: 'Thân thiết', DiscountPercent: 5, MinSpendPerYear: 5000000, KeepSpendPerYear: 3000000 },
    { RankID: 3, RankName: 'VIP', DiscountPercent: 10, MinSpendPerYear: 12000000, KeepSpendPerYear: 8000000 },
  ];
  for (const m of memberships) {
    writeLine(fd, `INSERT INTO dbo.Membership (RankID, RankName, DiscountPercent, MinSpendPerYear, KeepSpendPerYear, IsActive) VALUES (${m.RankID}, ${escape(m.RankName)}, ${m.DiscountPercent}, ${m.MinSpendPerYear}, ${m.KeepSpendPerYear}, 1);`);
  }

  // 2) Branches (10) - if Branch table exists; else user can adapt
  writeLine(fd, '\n-- Branches');
  const branchCities = ['Hồ Chí Minh', 'Hà Nội', 'Đà Nẵng', 'Cần Thơ', 'Hải Phòng', 'Nha Trang', 'Buôn Ma Thuột', 'Vũng Tàu', 'Bình Dương', 'Biên Hòa'];
  for (let i = 1; i <= CONFIG.branchCount; i++) {
    const name = `PetCareX ${branchCities[(i - 1) % branchCities.length]} ${i}`;
    writeLine(fd, `INSERT INTO dbo.Branch (BranchID, BranchName, Address, IsActive) VALUES (${i}, ${escape(name)}, ${escape(branchCities[(i - 1) % branchCities.length])}, 1);`);
  }

  // 3) Employees
  writeLine(fd, '\n-- Employees');
  const roles = ['Manager', 'Doctor', 'Cashier', 'Receptionist'];
  for (let i = 1; i <= CONFIG.employeesCount; i++) {
    const fullName = `Employee ${i}`;
    const phone = phoneFor(i + 100000);
    const role = roles[i % roles.length];
    writeLine(fd, `INSERT INTO dbo.Employee (EmployeeID, FullName, Role, Phone, IsActive) VALUES (${i}, ${escape(fullName)}, ${escape(role)}, ${escape(phone)}, 1);`);
  }

  // 4) EmployeeAssignment: ensure each employee has at least one current assignment
  writeLine(fd, '\n-- EmployeeAssignment (current and some history)');
  let eaId = 1;
  for (let emp = 1; emp <= CONFIG.employeesCount; emp++) {
    const branch = ((emp - 1) % CONFIG.branchCount) + 1; // spread employees across branches
    const start = '2020-01-01';
    // current assignment
    writeLine(fd, `INSERT INTO dbo.EmployeeAssignment (AssignmentID, EmployeeID, BranchID, StartDate, EndDate) VALUES (${eaId++}, ${emp}, ${branch}, ${escape(start)}, NULL);`);
    // some have history
    if (emp % 5 === 0) {
      const prevBranch = ((emp + 2) % CONFIG.branchCount) + 1;
      writeLine(fd, `INSERT INTO dbo.EmployeeAssignment (AssignmentID, EmployeeID, BranchID, StartDate, EndDate) VALUES (${eaId++}, ${emp}, ${prevBranch}, '2018-01-01', '2019-12-31');`);
    }
  }

  // 5) Services
  writeLine(fd, '\n-- Services');
  const serviceTypes = [];
  for (let i = 1; i <= CONFIG.servicesCount; i++) {
    let type = 'OTHER';
    if (i <= 20) type = 'EXAM';
    else if (i <= 40) type = 'VACCINE';
    serviceTypes.push(type);
    writeLine(fd, `INSERT INTO dbo.Service (ServiceID, ServiceName, ServiceType, IsActive) VALUES (${i}, ${escape('Service ' + i)}, ${escape(type)}, 1);`);
  }

  // 6) BranchService: each branch has >=8 EXAM and >=8 VACCINE and some OTHER
  writeLine(fd, '\n-- BranchService');
  let bsId = 1;
  for (let b = 1; b <= CONFIG.branchCount; b++) {
    // pick services for this branch
    const examIds = [];
    const vaccineIds = [];
    const otherIds = [];
    for (let s = 1; s <= CONFIG.servicesCount; s++) {
      if (serviceTypes[s - 1] === 'EXAM') examIds.push(s);
      if (serviceTypes[s - 1] === 'VACCINE') vaccineIds.push(s);
      if (serviceTypes[s - 1] === 'OTHER') otherIds.push(s);
    }
    // choose a subset
    function pick(arr, n) {
      const res = [];
      for (let i = 0; i < n; i++) res.push(arr[(i * 13 + b) % arr.length]);
      return res;
    }
    const pickExam = pick(examIds, 8);
    const pickVaccine = pick(vaccineIds, 8);
    const pickOther = pick(otherIds, Math.max(3, Math.floor(otherIds.length * 0.2)));
    const all = [...new Set([...pickExam, ...pickVaccine, ...pickOther])];
    for (const sid of all) {
      const price = randInt(100000, 1000000);
      writeLine(fd, `INSERT INTO dbo.BranchService (BranchID, ServiceID, ServicePrice, IsAvailable) VALUES (${b}, ${sid}, ${price}, 1);`);
    }
  }

  // 7) Products
  writeLine(fd, '\n-- Products');
  for (let p = 1; p <= CONFIG.productsCount; p++) {
    writeLine(fd, `INSERT INTO dbo.Product (ProductID, ProductName, ProductType, Unit, IsActive) VALUES (${p}, ${escape('Product ' + p)}, ${escape('GENERAL')}, ${escape('unit')}, 1);`);
  }

  // 8) Inventory: create exactly inventoryCount rows unique by (BranchID, ProductID)
  writeLine(fd, '\n-- Inventory');
  // We'll fill inventory by assigning products to branches round-robin until reaching target
  let invCount = 0;
  let prodId = 1;
  while (invCount < CONFIG.inventoryCount) {
    for (let b = 1; b <= CONFIG.branchCount && invCount < CONFIG.inventoryCount; b++) {
      writeLine(fd, `INSERT INTO dbo.Inventory (BranchID, ProductID, StockQty, SellingPrice, IsActive) VALUES (${b}, ${prodId}, ${randInt(0, 200)}, ${randInt(20000, 200000)}, 1);`);
      prodId++;
      if (prodId > CONFIG.productsCount) prodId = 1;
      invCount++;
    }
  }

  // 9) Users (must be created before Pets)
  writeLine(fd, '\n-- Users');
  for (let u = 1; u <= CONFIG.usersCount; u++) {
    const fullName = `User ${u}`;
    const email = emailFor(u);
    const phone = phoneFor(u);
    const cccd = `C${100000000 + u}`;
    const rank = ((u - 1) % 3) + 1;
    writeLine(fd, `INSERT INTO dbo.Users (UserID, FullName, Phone, Email, CCCD, RankID, LoyaltyPoints, IsActive) VALUES (${u}, ${escape(fullName)}, ${escape(phone)}, ${escape(email)}, ${escape(cccd)}, ${rank}, 0, 1);`);
  }

  // 10) Pets
  writeLine(fd, '\n-- Pets');
  const speciesPool = ['Dog', 'Cat', 'Bird', 'Rabbit', 'Other'];
  let petId = 1;
  for (let u = 1; u <= CONFIG.usersCount; u++) {
    const petsForUser = Math.random() < 0.2 ? 2 : 1; // ~80% have 1, 20% have 2
    for (let k = 0; k < petsForUser && petId <= CONFIG.petsCount; k++) {
      const species = speciesPool[(petId + u) % speciesPool.length];
      writeLine(fd, `INSERT INTO dbo.Pet (PetID, UserID, PetName, Species, Breed, IsActive) VALUES (${petId}, ${u}, ${escape('Pet ' + petId)}, ${escape(species)}, NULL, 1);`);
      petId++;
    }
  }

  // 11) Vaccines & Packages
  writeLine(fd, '\n-- Vaccines and Packages');
  for (let v = 1; v <= CONFIG.vaccinesCount; v++) {
    writeLine(fd, `INSERT INTO dbo.Vaccine (VaccineID, Name, IsActive) VALUES (${v}, ${escape('Vaccine ' + v)}, 1);`);
  }
  for (let pk = 1; pk <= CONFIG.vaccinePackagesCount; pk++) {
    const duration = [6, 12, 24][pk % 3];
    const discount = randInt(5, 15);
    writeLine(fd, `INSERT INTO dbo.VaccinePackage (PackageID, PackageName, DurationMonths, DiscountPercent, IsActive) VALUES (${pk}, ${escape('Package ' + pk)}, ${duration}, ${discount}, 1);`);
    // Package details: pick 3 vaccines per package
    for (let seq = 1; seq <= 3; seq++) {
      const vid = ((pk - 1) * 3 + seq) % CONFIG.vaccinesCount + 1;
      writeLine(fd, `INSERT INTO dbo.VaccinePackageDetail (PackageID, SequenceNo, VaccineID) VALUES (${pk}, ${seq}, ${vid});`);
    }
  }

  // 12) VaccinationSubscription (10k)
  writeLine(fd, '\n-- VaccinationSubscriptions');
  for (let s = 1; s <= CONFIG.vaccinationSubscriptionsCount; s++) {
    const userId = ((s - 1) % CONFIG.usersCount) + 1;
    const packageId = ((s - 1) % CONFIG.vaccinePackagesCount) + 1;
    const start = `2023-01-${String((s % 28) + 1).padStart(2, '0')}`;
    writeLine(fd, `INSERT INTO dbo.VaccinationSubscription (SubscriptionID, UserID, PackageID, StartDate, DiscountPercent, IsActive) VALUES (${s}, ${userId}, ${packageId}, ${escape(start)}, ${randInt(5,15)}, 1);`);
  }

  // 13) Appointments (70k) - only EXAM/VACCINE
  writeLine(fd, '\n-- Appointments (EXAM/VACCINE only)');
  const completedAppointments = []; // store completed appointments for later derived records
  for (let a = 1; a <= CONFIG.appointmentsCount; a++) {
    const userId = ((a - 1) % CONFIG.usersCount) + 1;
    const petIdAssign = ((a - 1) % CONFIG.petsCount) + 1;
    const isCompleted = Math.random() < RATIOS.appointments.completedPct;
    const rnd = Math.random();
    let status = 'Booked';
    if (isCompleted) status = 'Completed';
    else if (rnd < RATIOS.appointments.cancelledPct / (RATIOS.appointments.bookedPct + RATIOS.appointments.cancelledPct)) status = 'Cancelled';
    const serviceType = (Math.random() < RATIOS.completedType.examPct) ? 'EXAM' : 'VACCINE';
    let serviceId = 1;
    for (let s = 1; s <= CONFIG.servicesCount; s++) {
      if (serviceTypes[s - 1] === serviceType) { serviceId = s; break; }
    }
    const branchId = ((a - 1) % CONFIG.branchCount) + 1;
    const doctorId = (status === 'Cancelled') ? null : Math.floor(1 + ((branchId - 1) * 5 + (a % 5))); // simple doctor assignment
    const scheduleTime = `2024-${String(((a % 12) + 1)).padStart(2,'0')}-${String(((a % 28)+1)).padStart(2,'0')} 09:00:00`;
    writeLine(fd, `INSERT INTO dbo.Appointment (AppointmentID, BranchID, UserID, PetID, ServiceID, DoctorID, ScheduleTime, Status) VALUES (${a}, ${branchId}, ${userId}, ${petIdAssign}, ${serviceId}, ${doctorId === null ? 'NULL' : doctorId}, ${escape(scheduleTime)}, ${escape(status)});`);
    if (status === 'Completed') {
      completedAppointments.push({ appointmentId: a, branchId, userId, petId: petIdAssign, serviceId, serviceType, doctorId, scheduleTime });
    }
  }

  // 14) Derived records: ExamRecord / VaccinationRecord for Completed appointments
  writeLine(fd, '\n-- ExamRecord and VaccinationRecord for completed appointments');
  let examId = 1;
  let vaccId = 1;
  for (const ap of completedAppointments) {
    if (ap.serviceType === 'EXAM') {
      const notes = 'Auto-generated exam record';
      const nextVisit = (Math.random() < 0.5) ? null : `2024-01-${String(((ap.appointmentId % 28) + 1)).padStart(2,'0')}`;
      writeLine(fd, `INSERT INTO dbo.ExamRecord (ExamRecordID, AppointmentID, DoctorID, Notes, NextVisitDate) VALUES (${examId++}, ${ap.appointmentId}, ${ap.doctorId}, ${escape(notes)}, ${nextVisit ? escape(nextVisit) : 'NULL'});`);
    } else {
      // VaccinationRecord: 70% belong to a subscription/package
      const useSub = Math.random() < 0.7;
      const subscriptionId = useSub ? (((ap.appointmentId - 1) % CONFIG.vaccinationSubscriptionsCount) + 1) : null;
      const dateGiven = ap.scheduleTime.split(' ')[0];
      writeLine(fd, `INSERT INTO dbo.VaccinationRecord (VaccinationRecordID, AppointmentID, DoctorID, VaccineID, DateGiven, SubscriptionID) VALUES (${vaccId++}, ${ap.appointmentId}, ${ap.doctorId}, ${ap.serviceId /* approximate mapping */}, ${escape(dateGiven)}, ${subscriptionId ? subscriptionId : 'NULL'});`);
    }
  }

  // 15) Invoices: create service invoices for completed appointments and purchase-only invoices to reach total
  writeLine(fd, '\n-- Invoices and Invoice lines');
  let invoiceId = 1;
  const serviceInvoicesTarget = Math.min(completedAppointments.length, 50000);
  const purchaseInvoicesTarget = CONFIG.invoicesCount - serviceInvoicesTarget;

  // Helper: choose a staff (Cashier/Receptionist) for a branch
  function staffForBranch(branch) {
    // choose an employee id that maps to branch: simple mapping
    return (branch) + 100; // offset to hit some employee ids
  }

  // Service invoices
  for (let i = 0; i < serviceInvoicesTarget; i++) {
    const ap = completedAppointments[i];
    const original = randInt(200000, 1000000);
    const discount = 0; // could be based on subscription
    const final = original - discount;
    const staff = staffForBranch(ap.branchId);
    writeLine(fd, `INSERT INTO dbo.Invoice (InvoiceID, BranchID, UserID, StaffID, InvoiceDate, OriginalAmount, DiscountAmount, FinalAmount, PaymentMethod, PaymentStatus) VALUES (${invoiceId}, ${ap.branchId}, ${ap.userId}, ${staff}, ${escape(ap.scheduleTime)}, ${original}, ${discount}, ${final}, ${escape('Cash')}, ${escape('Paid')});`);
    // InvoicePet
    writeLine(fd, `INSERT INTO dbo.InvoicePet (InvoiceID, PetID) VALUES (${invoiceId}, ${ap.petId});`);
    // ServiceInvoiceLine
    writeLine(fd, `INSERT INTO dbo.ServiceInvoiceLine (InvoiceID, LineNo, ServiceID, AppointmentID, PetID, Quantity, UnitPrice, LineAmount, DiscountAmount) VALUES (${invoiceId}, 1, ${ap.serviceId}, ${ap.appointmentId}, ${ap.petId}, 1, ${original}, ${original}, ${discount});`);
    // LoyaltyTransaction
    const points = Math.floor(final / 50000);
    if (points > 0) {
      writeLine(fd, `INSERT INTO dbo.LoyaltyTransaction (TransactionID, UserID, InvoiceID, Points, TransactionDate) VALUES (${invoiceId}, ${ap.userId}, ${invoiceId}, ${points}, ${escape(ap.scheduleTime)});`);
      writeLine(fd, `UPDATE dbo.Users SET LoyaltyPoints = LoyaltyPoints + ${points} WHERE UserID = ${ap.userId};`);
    }
    invoiceId++;
  }

  // Purchase-only invoices
  for (let p = 0; p < purchaseInvoicesTarget; p++) {
    const userId = ((p) % CONFIG.usersCount) + 1;
    const branch = ((p) % CONFIG.branchCount) + 1;
    const original = randInt(50000, 500000);
    const final = original;
    const staff = staffForBranch(branch);
    writeLine(fd, `INSERT INTO dbo.Invoice (InvoiceID, BranchID, UserID, StaffID, InvoiceDate, OriginalAmount, DiscountAmount, FinalAmount, PaymentMethod, PaymentStatus) VALUES (${invoiceId}, ${branch}, ${userId}, ${staff}, ${escape('2024-01-01')}, ${original}, 0, ${final}, ${escape('Cash')}, ${escape('Paid')});`);
    // Add a product line
    const prodIdLine = ((p) % CONFIG.productsCount) + 1;
    writeLine(fd, `INSERT INTO dbo.ProductInvoiceLine (InvoiceID, LineNo, ProductID, Quantity, UnitPrice, LineAmount, DiscountAmount) VALUES (${invoiceId}, 1, ${prodIdLine}, 1, ${final}, ${final}, 0);`);
    // Loyalty
    const points = Math.floor(final / 50000);
    if (points > 0) {
      writeLine(fd, `INSERT INTO dbo.LoyaltyTransaction (TransactionID, UserID, InvoiceID, Points, TransactionDate) VALUES (${invoiceId}, ${userId}, ${invoiceId}, ${points}, ${escape('2024-01-01')});`);
      writeLine(fd, `UPDATE dbo.Users SET LoyaltyPoints = LoyaltyPoints + ${points} WHERE UserID = ${userId};`);
    }
    invoiceId++;
  }

  // 16) Ratings: create ratings for a subset of service invoices (only paid service invoices)
  writeLine(fd, '\n-- Ratings');
  let ratingId = 1;
  const ratingsToCreate = Math.min(CONFIG.ratingsCount, serviceInvoicesTarget);
  for (let r = 1; r <= ratingsToCreate; r++) {
    const inv = r; // assume service invoice IDs start at 1
    const score = randInt(3, 5);
    writeLine(fd, `INSERT INTO dbo.Rating (RatingID, InvoiceID, UserID, EmployeeID, Score, Comment, CreatedAt) VALUES (${ratingId++}, ${inv}, (SELECT UserID FROM dbo.Invoice WHERE InvoiceID = ${inv}), (SELECT StaffID FROM dbo.Invoice WHERE InvoiceID = ${inv}), ${score}, ${escape('Auto rating')}, ${escape('2024-01-01')});`);
  }

  writeLine(fd, '\n-- End of generated seed');
  fs.closeSync(fd);
  console.log('Seed SQL generation complete. Review', OUT_SQL, 'before running.');
}

// helper to map emp for branch (simple round-robin)
function empForBranch(branchId) {
  return branchId; // simplistic mapping; can be improved
}

// run
generate().catch((err) => { console.error(err); process.exit(1); });
